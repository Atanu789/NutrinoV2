/**
 * Parses the original meal plan text and converts it to a structured JSON format
 * @param {string} originalPlanText - The raw meal plan text generated by AI
 * @returns {Object} Structured meal plan data in JSON format
 */
export function parseMealPlanText(originalPlanText) {
  const result = {
    nutritionalGoals: [],
    restrictions: [],
    aiRecommendations: {
      generalStrategy: "",
      foodsToEmphasize: [],
      foodsToAvoid: [],
      mealPrepTips: [],
      hydrationAdvice: ""
    },
    dailyPlans: []
  };

  // Extract the nutrition strategy section
  const strategyMatch = originalPlanText.match(/\*\*Overall Nutrition Strategy:\*\*([\s\S]*?)(?=\*\*Tips for Meal Preparation|$)/);
  if (strategyMatch && strategyMatch[1]) {
    // Set general strategy
    result.aiRecommendations.generalStrategy = "Focus on DASH diet principles, antioxidant-rich foods, and reduced sodium intake for managing hypertension and asthma.";

    // Extract strategy points
    const strategyPoints = strategyMatch[1].match(/\*\s+(.*?)(?=\*\s+|$)/g) || [];
    strategyPoints.forEach(point => {
      const cleanPoint = point.replace(/\*\s+/, '').trim();
      if (cleanPoint.includes("DASH Diet")) {
        result.nutritionalGoals.push({
          goal: "Follow DASH Diet Principles",
          reason: "Managing hypertension and overall heart health",
          recommendations: ["Prioritize fruits, vegetables, whole grains, and lean protein", "Limit sodium, saturated fat, and added sugars"]
        });
      } else if (cleanPoint.includes("Antioxidant")) {
        result.nutritionalGoals.push({
          goal: "Increase Antioxidant Intake",
          reason: "Support recovery from smoking and manage asthma",
          recommendations: ["Include berries, colorful vegetables, and foods rich in Vitamin C and E"]
        });
      } else if (cleanPoint.includes("Hypertension")) {
        result.nutritionalGoals.push({
          goal: "Control Sodium Intake",
          reason: "Managing hypertension",
          recommendations: ["Keep sodium below 2300mg/day", "Increase potassium-rich foods", "Include magnesium-rich foods"]
        });
      } else if (cleanPoint.includes("Gut Health")) {
        result.nutritionalGoals.push({
          goal: "Improve Gut Health",
          reason: "Reduce bloating and digestive issues",
          recommendations: ["Include probiotic-rich foods (yogurt, kefir)", "Increase fiber intake gradually"]
        });
      }
    });
  }

  // Extract meal preparation tips
  const tipsMatch = originalPlanText.match(/\*\*Tips for Meal Preparation and Planning:\*\*([\s\S]*?)(?=\*\*Foods to Emphasize|$)/);
  if (tipsMatch && tipsMatch[1]) {
    const tipPoints = tipsMatch[1].match(/\*\s+(.*?)(?=\*\s+|$)/g) || [];
    tipPoints.forEach(tip => {
      const cleanTip = tip.replace(/\*\s+/, '').trim();
      result.aiRecommendations.mealPrepTips.push(cleanTip);
    });
  }

  // Extract foods to emphasize
  const emphasizeMatch = originalPlanText.match(/\*\*Foods to Emphasize:\*\*([\s\S]*?)(?=\*\*Foods to Avoid|$)/);
  if (emphasizeMatch && emphasizeMatch[1]) {
    const emphasizeLines = emphasizeMatch[1].trim().split('\n');
    emphasizeLines.forEach(line => {
      const cleanLine = line.replace(/\*\s+/, '').trim();
      if (cleanLine && !cleanLine.startsWith('**')) {
        result.aiRecommendations.foodsToEmphasize.push(cleanLine);
      }
    });
  }

  // Extract foods to avoid
  const avoidMatch = originalPlanText.match(/\*\*Foods to Avoid:\*\*([\s\S]*?)(?=\*\*Hydration|$)/);
  if (avoidMatch && avoidMatch[1]) {
    const avoidLines = avoidMatch[1].trim().split('\n');
    avoidLines.forEach(line => {
      const cleanLine = line.replace(/\*\s+/, '').trim();
      if (cleanLine && !cleanLine.startsWith('**')) {
        result.aiRecommendations.foodsToAvoid.push(cleanLine);
      }
    });
  }

  // Extract hydration advice
  const hydrationMatch = originalPlanText.match(/\*\*Hydration Recommendations:\*\*([\s\S]*?)(?=\*\*7-Day|$)/);
  if (hydrationMatch && hydrationMatch[1]) {
    const hydrationLines = hydrationMatch[1].trim().split('\n');
    const firstLine = hydrationLines[0].replace(/\*\s+/, '').trim();
    result.aiRecommendations.hydrationAdvice = firstLine;
  }

  // Extract daily meal plans
  for (let day = 1; day <= 7; day++) {
    const dayRegex = new RegExp(`\\*\\*Day ${day}\\*\\*(\\s|.)*?(?=\\*\\*Day ${day + 1}|\\*\\*Important Considerations|$)`, 'g');
    const dayMatch = originalPlanText.match(dayRegex);

    if (dayMatch && dayMatch[0]) {
      const dayPlan = {
        day: day,
        dayName: `Day ${day}`,
        totalCalories: calculateTotalCalories(dayMatch[0]),
        totalProtein: calculateTotalProtein(dayMatch[0]),
        totalCarbs: calculateTotalCarbs(dayMatch[0]),
        totalFat: calculateTotalFat(dayMatch[0]),
        waterIntake: 2500, // From the text: "Water Intake: 2.5 liters"
        meals: extractMeals(dayMatch[0]),
        notes: ""
      };

      result.dailyPlans.push(dayPlan);
    }
  }

  return result;
}

/**
 * Extract meals from a day's meal plan text
 * @param {string} dayText - The text for a single day's meal plan
 * @returns {Array} Array of meal objects
 */
function extractMeals(dayText) {
  const meals = [];

  // Extract breakfast
  const breakfastMatch = dayText.match(/\*\*Breakfast:\*\*([\s\S]*?)(?=\*\*Lunch|$)/);
  if (breakfastMatch && breakfastMatch[1]) {
    const breakfast = parseMeal(breakfastMatch[1], "BREAKFAST");
    meals.push(breakfast);
  }

  // Extract lunch
  const lunchMatch = dayText.match(/\*\*Lunch:\*\*([\s\S]*?)(?=\*\*Dinner|$)/);
  if (lunchMatch && lunchMatch[1]) {
    const lunch = parseMeal(lunchMatch[1], "LUNCH");
    meals.push(lunch);
  }

  // Extract dinner
  const dinnerMatch = dayText.match(/\*\*Dinner:\*\*([\s\S]*?)(?=\*\*Snack|$)/);
  if (dinnerMatch && dinnerMatch[1]) {
    const dinner = parseMeal(dinnerMatch[1], "DINNER");
    meals.push(dinner);
  }

  // Extract snacks
  const snack1Match = dayText.match(/\*\*Snack 1:\*\*([\s\S]*?)(?=\*\*Snack 2|\*\*Water|$)/);
  if (snack1Match && snack1Match[1]) {
    const snack1 = parseMeal(snack1Match[1], "SNACK");
    meals.push(snack1);
  }

  const snack2Match = dayText.match(/\*\*Snack 2:\*\*([\s\S]*?)(?=\*\*Water|$)/);
  if (snack2Match && snack2Match[1]) {
    const snack2 = parseMeal(snack2Match[1], "SNACK");
    meals.push(snack2);
  }

  return meals;
}

/**
 * Parse a meal section into a structured meal object
 * @param {string} mealText - The text for a single meal
 * @param {string} mealType - The type of meal (BREAKFAST, LUNCH, DINNER, SNACK)
 * @returns {Object} Structured meal object
 */
function parseMeal(mealText, mealType) {
  // Default meal structure
  const meal = {
    mealType: mealType,
    name: "",
    description: "",
    calories: 0,
    protein: 0,
    carbs: 0,
    fat: 0,
    ingredients: [],
    preparationSteps: [],
    preparationTime: 15, // Default prep time
    healthBenefits: []
  };

  // Extract nutritional info
  const nutritionMatch = mealText.match(/\((.*?)\)/);
  if (nutritionMatch && nutritionMatch[1]) {
    const nutritionParts = nutritionMatch[1].split(',');
    nutritionParts.forEach(part => {
      const cleanPart = part.trim();
      if (cleanPart.includes('calories')) {
        meal.calories = parseInt(cleanPart.split(' ')[0]) || 0;
      } else if (cleanPart.includes('protein')) {
        meal.protein = parseInt(cleanPart.split('g')[0].trim().split(' ').pop()) || 0;
      } else if (cleanPart.includes('carbs')) {
        meal.carbs = parseInt(cleanPart.split('g')[0].trim().split(' ').pop()) || 0;
      } else if (cleanPart.includes('fat')) {
        meal.fat = parseInt(cleanPart.split('g')[0].trim().split(' ').pop()) || 0;
      }
    });
  }

  // Extract name
  const firstLine = mealText.trim().split('\n')[0];
  if (firstLine) {
    const nameParts = firstLine.split('(');
    meal.name = nameParts[0].trim();
  }

  // Extract description
  const descriptionMatch = mealText.match(/\*\s+Description:(.*?)(?=\*\s+Ingredients|$)/);
  if (descriptionMatch && descriptionMatch[1]) {
    meal.description = descriptionMatch[1].trim();
  }

  // Extract ingredients
  const ingredientsMatch = mealText.match(/\*\s+Ingredients:(.*?)(?=\*\s+Preparation|$)/);
  if (ingredientsMatch && ingredientsMatch[1]) {
    const ingredientsList = ingredientsMatch[1].trim().split(',');
    ingredientsList.forEach(ingredient => {
      const cleanIngredient = ingredient.trim();
      if (cleanIngredient) {
        meal.ingredients.push(cleanIngredient);
      }
    });
  }

  // Extract preparation steps
  const prepMatch = mealText.match(/\*\s+Preparation:(.*?)(?=\*\s+Health Benefits|$)/);
  if (prepMatch && prepMatch[1]) {
    const prepSteps = prepMatch[1].trim().split('.');
    prepSteps.forEach(step => {
      const cleanStep = step.trim();
      if (cleanStep) {
        meal.preparationSteps.push(cleanStep);
      }
    });
  }

  // Extract health benefits
  const benefitsMatch = mealText.match(/\*\s+Health Benefits:(.*?)(?=$)/);
  if (benefitsMatch && benefitsMatch[1]) {
    const benefitsList = benefitsMatch[1].trim().split(',');
    benefitsList.forEach(benefit => {
      const cleanBenefit = benefit.trim();
      if (cleanBenefit) {
        meal.healthBenefits.push(cleanBenefit);
      }
    });
  }

  return meal;
}

/**
 * Calculate total calories for a day from all meals
 * @param {string} dayText - The text for a single day's meal plan
 * @returns {number} Total calories
 */
function calculateTotalCalories(dayText) {
  let total = 0;
  const caloriesMatches = dayText.matchAll(/\((\d+) calories/g);

  for (const match of caloriesMatches) {
    total += parseInt(match[1]) || 0;
  }

  return total;
}

/**
 * Calculate total protein for a day from all meals
 * @param {string} dayText - The text for a single day's meal plan
 * @returns {number} Total protein in grams
 */
function calculateTotalProtein(dayText) {
  let total = 0;
  const matches = dayText.matchAll(/(\d+)g protein/g);

  for (const match of matches) {
    total += parseInt(match[1]) || 0;
  }

  return total;
}

/**
 * Calculate total carbs for a day from all meals
 * @param {string} dayText - The text for a single day's meal plan
 * @returns {number} Total carbs in grams
 */
function calculateTotalCarbs(dayText) {
  let total = 0;
  const matches = dayText.matchAll(/(\d+)g carbs/g);

  for (const match of matches) {
    total += parseInt(match[1]) || 0;
  }

  return total;
}

/**
 * Calculate total fat for a day from all meals
 * @param {string} dayText - The text for a single day's meal plan
 * @returns {number} Total fat in grams
 */
function calculateTotalFat(dayText) {
  let total = 0;
  const matches = dayText.matchAll(/(\d+)g fat/g);

  for (const match of matches) {
    total += parseInt(match[1]) || 0;
  }

  return total;
}

// Example usage:
// const structuredMealPlan = parseMealPlanText(originalPlanText);
